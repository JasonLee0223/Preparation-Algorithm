# 마스터즈 코스 준비

## 📋 4673번 셀프 넘버
### 📜 문제내용   
   1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.   
   양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), ...과 같은 무한 수열을 만들 수 있다.   
   예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다.   
   이런식으로 다음과 같은 수열을 만들 수 있다.   
   n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다.    
   생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97
> 📝 풀이과정
* 중복되는 값이 없어야한다. -> Set 사용   
   
* 셀프 넘버의 이유를 알아봐야한다.   
만드는 숫자(ex. 1,33)에 초점을 두지 않고 만들어진 숫자(ex. 2,39)에 초점을 둬야한다.   
예를 들어, '2'는 앞에 있던 1이 1 + 1 = 2로 만들어지므로 Self-Number가 아니게되고 '4'역시 2 + 2 = 4로 만들어지므로 Self-Number가 아니다.   

* 그럼 셀프 넘버는 왜 Self-Number일까??   
위와 반면에 '3'은 이전 수들로 조합이 만들어지지 않으므로 Self-Number이며 '5'역시 마찬가지이다.   
그렇기 때문에 '10'은 5 + 5 = 10으로 Self-Number는 아니지만 '20'은 14 -> 14 + 1 + 4 = 19, 15 -> 15 + 1 + 5 = 21 로 조합이 만들어지지 않아 Self-Number에 해당되어진다.   

* 논리식으로 표현해보자.   
  - ▶︎ 생성자가 존재하는 경우   
예를 들어, 전달 받은 값이 '1'이라면   
1 (전달 받은 값) + 1 (각 자리수) = 2 (결과)   
즉, 결과값이 '2'인 경우 생성자인 '1'(전달 받은 값)이 존재하므로 Self-Number가 아니게된다.   
  - ▶︎ 생성자가 존재하지않는 경우(Self-Number) 결과값을 '3'이라고 가정해보면    
? (전달 받은 값) + ? (각 자리수) = 3 (결과) 다시 규칙을 살펴보면,   
'양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수' 결과값인 '3'의 경우, 일의 자리수이므로 전달 받은 값인 'n' 값과 'n'의 자리수를 더하여 '3'이 나와야 한다. 즉, n＋n = 3 이 식이 성립해야 하는 것이다.    
***
## 📋 1065번 한수
### 📜 문제내용   
어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다.   
등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. N이 주어졌을 때,   
1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.   
> 📝 풀이과정1   
* 한수란...?   
   예를들어, 한자리 수인 '1,2,3'도 한수이며 '111,135,369...'등도   
   한수가 될 수 있다. 각 자리의 차이가 동일하기 때문이다.   

* 우선 입력값을 받아야함으로 강제 언래핑을 사용하며 답을 입력받을 변수를 선언한다.   
   ```   
   let inputValue = Int(readLine()!)!
   var cnt = 0
   ```   
* 각 자리의 수를 나눠야한다.   
   등차 = 1의자리 수 - 10의자리수   
   1의 자리 수  = n % 10   
   10의 자리 수 = (n%100) / 10   

* 위와 같이 로직을 구현하여 실패...   
   ```   
   func calculateHansu(_ num: Int) -> Bool {
        var number = num
        let d = number%10 - (number%100)/10
        // ex. 110 -> 10 - 1 = 9
        var place1 = number%10
        
        if num < 10 {
            return true
        } //예외처리
        
        number /= 10
        while number > 0 {
            if d != place1 - num % 10 {
                return false
            }
            place1 = number % 10
            number /= 10
        }
        return true
    }   
    ```    
* 110의 예시를 넣었더니 19밖에 나오지 않았다.   
   문제에 대한 잘못된 이해로 시도를 잘못하였다.   

> 📝 풀이과정2 
* 외부링크: < https://www.acmicpc.net/board/view/25689 >
* 1의 자리와 10의 자리수는 비교할 대상이 없어 예외처리한다.
* 빈 배열을 선언하여 100 이상의 수부터는 각 배열의 값을 비교하여 처리한다. 
***
## 📋 1009번 분산처리
### 📜 문제내용   
   재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.   
   1번 데이터는 1번 컴퓨터, 2번 데이터는 2번 컴퓨터, 3번 데이터는 3번 컴퓨터, ... ,   
   10번 데이터는 10번 컴퓨터, 11번 데이터는 1번 컴퓨터, 12번 데이터는 2번 컴퓨터, ...   
   총 데이터의 개수는 항상 a^b개의 형태로 주어진다. 재용이는 문득 마지막 데이터가 처리될 컴퓨터의 번호가 궁금해졌다. 이를 수행해주는 프로그램을 작성하라.
> 📝 풀이과정
#### <center>< 조건 ><center>   
   1. 컴퓨터 10대라는 고정크기   
   2. COM1 ~ COM10 까지 데이터 처리 후 11번째부터는 다시 COM1으로 돌아와서 처리하는 함수?(로직?)를 구현해야겠다.
   3. 총 데이터의 개수는 a^b개의 형태로 주어진다. (입력 a, b)
   4. 첫 줄에는 테스트 케이스의 개수 T 가 주어진다.
   5. 그 다음 줄부터 각각의 테스트 케이스에 대해 정수 a, b가 주어진다.  
   (1 ≤ a < 100, 1 ≤ b < 1,000,000)
   6. 각 테스트 케이스에 대해 마지막 데이터가 처리되는 컴퓨터의 번호를 출력   

#### <center>< ❗️ 주의할 점 ❗️ ><center>
```
   // 출력 예시 
   1 6 = 1  
   3 7 = ...7   
   6 2 = ...6   
   7 100 = ...1 -> 범위초과오류 발생   
   9 635 = ...9 -> 범위초과오류 발생
```
- 이 문제는 10으로 나눈 나머지를 계속 구하면서 곱하기만 하면 마지막 컴퓨터의 1의 자릿수가 뭔지 알아내는 문제
- 주의할 점 마지막 1의 자릿수가 0으로 떨어지는 경우 0번 컴퓨터가 아닌 10번 컴퓨터가 답이다.  
- 수의 반복 -> 0~9까지 동일한 숫자를 계속 곱할 경우 1의 자릿수가 0일 경우, 즉 원래 값이 10일 경우 -> 계속 곱해봐도 0이다.   
- 즉, 모든 숫자가 자신의 숫자에 제곱을 연속해서 곱해줄 경우 1의 자릿수는 최대 4주기마다 똑같은 숫자를 반복 100번 제곱하던 4번 제곱하던 1의 자릿수의 결과는 똑같으므로 제곱횟수를 4로 나누었을때는 0이 되는데 0제곱은 수학에서 결과값이 1이 되므로 예외입니다.

***
## 📋 1076번 저항
### 📜 문제내용   
전자 제품에는 저항이 들어간다. 저항은 색 3개를 이용해서 그 저항이 몇 옴인지 나타낸다.  
처음 색 2개는 저항의 값이고, 마지막 색은 곱해야 하는 값이다. 저항의 값은 다음 표를 이용해서 구한다.
|  <center>색</center> |  <center>값</center> |  <center>곱</center> |
|:--------|:--------:|--------:|
|<center>black</center> | <center>0</center>  |<center>1</center>  |
|<center>brown</center> | <center>1</center>  |<center>10</center>  |
|<center>red</center> | <center>2</center>  |<center>100</center>  |
|<center>orange</center> | <center>3</center>  |<center>1,000</center>  |
|<center>yellow</center> | <center>4</center>  |<center>10,000</center>  |
|<center>green</center> | <center>5</center>  |<center>100,000</center>  |
|<center>blue</center> | <center>6</center>  |<center>1,000,000</center>  |
|<center>violet</center> | <center>7</center>  |<center>10,000,000</center>  |
|<center>grey</center> | <center>8</center>  |<center>100,000,000</center>  |
|<center>white</center> | <center>9</center>  |<center>1,000,000,000</center>  |

예를 들어, 저항의 색이 yellow, violet, red 였다면 저항의 값은 4,700이 된다. (ex. 47 * 100 = 4700)
#### <center>< 조건 ><center>   
- 입력: 각 줄에 맞는 색이 주어진다. (위 표에 있는 색만 입력으로 주어진다.)
- 출력: 입력으로 주어진 저항의 저항값을 계산하여 첫째 줄에 출력한다.

> 📝 풀이과정1
- 주어진 count=3 으로 readline()을 반복문을 통하여 고정된 빈 배열에 값을 담는다.
- switch 제어문을 통하여 value값을 저장한다.
- pow함수를 사용하여 제곱근을 풀어낸다.
- 저항값은 (arr[0]*10 + arr[1])*(10의 arr[2]제곱)이 된다.
> 📝 풀이과정2

***
## 📋 1052번 물병
### 📜 문제내용   
지민이는 N개의 물병을 가지고 있다. 각 물병에는 물을 무한대로 부을 수 있다. 처음에 모든 물병에는 물이 1리터씩 들어있다. 지민이는 이 물병을 또 다른 장소로 옮기려고 한다. 지민이는 한 번에 K개의 물병을 옮길 수 있다. 하지만, 지민이는 물을 낭비하기는 싫고, 이동을 한 번보다 많이 하기는 싫다. 따라서, 지민이는 물병의 물을 적절히 재분배해서, K개를 넘지 않는 비어있지 않은 물병을 만들려고 한다.

물은 다음과 같이 재분배 한다.

먼저 같은 양의 물이 들어있는 물병 두 개를 고른다. 그 다음에 한 개의 물병에 다른 한 쪽에 있는 물을 모두 붓는다. 이 방법을 필요한 만큼 계속 한다.
이런 제약 때문에, N개로 K개를 넘지않는 비어있지 않은 물병을 만드는 것이 불가능할 수도 있다. 다행히도, 새로운 물병을 살 수 있다. 상점에서 사는 물병은 물이 1리터 들어있다.

예를 들어, N=3이고, K=1일 때를 보면, 물병 3개로 1개를 만드는 것이 불가능하다. 한 병을 또다른 병에 부으면, 2리터가 들어있는 물병 하나와, 1리터가 들어있는 물병 하나가 남는다. 만약 상점에서 한 개의 물병을 산다면, 2리터가 들어있는 물병 두 개를 만들 수 있고, 마지막으로 4리터가 들어있는 물병 한 개를 만들 수 있다.

#### <center>< 조건 ><center>   
- 입력: 첫째 줄에 N과 K가 주어진다. N은 107보다 작거나 같은 자연수이고, K는 1,000보다 작거나 같은 자연수이다.
- 출력: 첫째 줄에 상점에서 사야하는 물병의 최솟값을 출력한다. 만약 정답이 없을 경우에는 -1을 출력한다.
> 📝 풀이과정  


***
## 📋 10757번 큰 수 A + B
### 📜 문제내용 
두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오. 
#### <center>< 조건 ><center>   
- 입력: 첫째 줄에 A와 B가 주어진다. (0 < A,B < 1010000)
- 출력: 첫째 줄에 A+B를 출력한다.   
Ex) 9223372036854775807 9223372036854775808 = 18446744073709551615